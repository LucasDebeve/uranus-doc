---
id: tdd
title: 'Test Driven Development avec PHPUnit'
description: Le Test Driven Development (TDD) est une approche de d√©veloppement logiciel qui consiste √† √©crire les tests avant le code de production.
slug: /tdd
---

## Introduction

## Le d√©veloppement dirig√© par les tests (TDD)

Imaginez construire une maison en ne posant les briques **que** quand vous savez **exactement** pourquoi elles sont l√†. C'est √ßa, le TDD (Test-Driven Development) : √©crire un test **avant** m√™me d'√©crire le code.


### La boucle TDD : Red ‚Üí Green ‚Üí Refactor

Le TDD repose sur un cycle simple en trois √©tapes :

1. **Red** : √âcrire un test **qui √©choue** parce que la fonctionnalit√© n'existe pas encore.
2. **Green** : √âcrire **le minimum de code** pour faire passer le test.
3. **Refactor** : Nettoyer et am√©liorer le code **sans casser le test**.

Et on recommence !

### Exemple pas √† pas : une classe `StringHelper`

Nous allons d√©velopper une m√©thode `isPalindrome(string $input): bool`, qui v√©rifie si une cha√Æne est un palindrome.

#### √âtape 1 : Red ‚Äî √©crire un test qui √©choue

```php
<?php

use PHPUnit\Framework\TestCase;
use App\StringHelper;

class StringHelperTest extends TestCase
{
    public function testIsPalindromeReturnsTrueForSimplePalindrome(): void
    {
        $helper = new StringHelper();
        $this->assertTrue($helper->isPalindrome('radar'));
    }
}
```

√Ä ce stade, `StringHelper` n'existe m√™me pas. Le test √©choue avec une erreur de type Class not found.

#### √âtape 2 : Green ‚Äî cr√©er juste assez de code

On cr√©e la classe et la m√©thode pour que le test passe (m√™me en "trichant" un peu) :

```php	
<?php

namespace App;

class StringHelper
{
    public function isPalindrome(string $input): bool
    {
        return true; // solution temporaire pour passer le test
    }
}
```

Lancez PHPUnit : ‚úÖ Le test passe. Mais‚Ä¶ on a cod√© un cas tr√®s sp√©cifique.

#### √âtape 3 : Refactor ‚Äî g√©n√©raliser et am√©liorer

On ajoute un deuxi√®me test pour un mot qui n'est pas un palindrome :

```php
public function testIsPalindromeReturnsFalseForNonPalindrome(): void
{
    $helper = new StringHelper();
    $this->assertFalse($helper->isPalindrome('bonjour'));
}
```

Ce test √©choue (Red üî¥) ? Parfait. Maintenant, on √©crit une vraie logique :

```php
public function isPalindrome(string $input): bool
{
    $normalized = strtolower(preg_replace('/[^a-z]/i', '', $input));
    return $normalized === strrev($normalized);
}
```

Relancez les tests : ‚úÖ Green. Les deux cas passent. Vous pouvez maintenant faire un peu de refactor si besoin.

## Pourquoi faire du TDD ?

- Vous pensez **d'abord au besoin**, pas √† l'impl√©mentation.
- Vous obtenez une **documentation vivante** du comportement attendu.
- Vous avez plus confiance pour refactorer : les tests garantissent que le comportement ne change pas.

## Bonnes pratiques TDD

- **Commencez simple**. Testez d'abord les cas √©vidents, puis les exceptions.
- **Un test √† la fois**. Ne pas √©crire dix assertions en une m√©thode.
- N'√©crivez **pas de code sans test**. M√™me un peu.
- **Refactorez souvent**, mais entre deux √©tapes Green.

## Et dans Symfony ?

Vous pouvez tout √† fait faire du TDD avec vos services Symfony (et m√™me vos contr√¥leurs, via les tests fonctionnels).

Exemple : vous √©crivez le test d'un service `UserSlugger`, puis vous l'impl√©mentez petit √† petit en suivant la boucle Red ‚Üí Green ‚Üí Refactor.

