---
id: sae-maze
title: SAE Labyrinthe
description: Sujet SAE Labyrinthe
slug: /sae-maze
sidebar_position: 1
---

# Labyrinthe

Dans cette Situation d'Apprentissage et d'Ã‰valuation, vous allez devoir implÃ©menter des algorithmes de gÃ©nÃ©ration et de rÃ©solution de labyrinthes.
## PrÃ©ambule

### Notes sur l'organisation et l'Ã©valuation

- Le projet est Ã  rÃ©aliser **en binÃ´mes**.
- Vous devez versionner votre travail avec `git`.
- Le dÃ©pÃ´t distant sera sur l'instance `Gitlab` **du dÃ©partement informatique de l'IUT de Reims** : [https://iut-info.univ-reims.fr/gitlab/](https://iut-info.univ-reims.fr/gitlab/).
- Il faut effectuer des `commits` **rÃ©guliers** (Ã  chaque fois que vous travaillez sur votre projet et _a minima_ pour chaque fonction/question).
- Un **entretien oral** avec votre enseignant rÃ©fÃ©rent permettra de **vous aider Ã  rÃ©aliser votre projet** et vous permettra de vous entraÃ®ner.
- Il est dÃ©conseillÃ© d'inclure dans votre notebook et dans votre dÃ©pÃ´t, des solutions que vous n'auriez pas trouvÃ©es vous-mÃªme, ou que vous n'auriez pas comprises.

L'essentiel du travail est donc Ã  rÃ©aliser dans un `notebooks` `jupyter`. Vous pouvez utiliser l'instance`jupyterhub` du dÃ©partement.

## Consignes

- **Votre** code devra respecter quelques rÃ¨gles d'**hygiÃ¨ne** Ã©lÃ©mentaire :
  - contenir des commentaires (**a minima** un `docstring` informatif pour chaque mÃ©thode),
  - Ãªtre lisible (en essayant d'utiliser des noms de variables explicites).

- Respectez la progression du sujet dans la prÃ©sentation de votre _notebook_.
- Le travail est Ã  rÃ©aliser en binÃ´me Chaque membre du binÃ´me doit Ãªtre capable de rÃ©pondre seul Ã  des questions portant sur ce qui a Ã©tÃ© rÃ©alisÃ©.

## ModÃ©lisation d'un labyrinthe

Un labyrinthe est un graphe non-orientÃ© (ou orientÃ©-symÃ©trique) dont la reprÃ©sentation planaire prend la forme d'une grille. Chaque **cellule** du labyrinthe est un sommet du graphe, et l'absence de mur entre deux cellules contiguÃ«s constitue une arÃªte.

On parle de labyrinthe parfait lorsque le graphe est un arbre (donc connexe et sans cycle). Par la suite, sauf mention du contraire, un labyrinthe sera considÃ©rÃ© comme parfait.

[ReprÃ©sentation d'un graphe parfait sous forme d'un arbre](https://upload.wikimedia.org/wikipedia/commons/6/69/Yl_maze_ani_algo1.gif)

<img src={require('./images/labyrinthe-graphe.png').default} alt="Arbre binaire" style={{maxHeight : "200px"}}/>

La modÃ©lisation retenue dans ce projet consiste Ã  reprÃ©senter un **sommet** par un **couple** (indice de ligne, indice de colonne) permettant de localiser la cellule, et d'utiliser un dictionnaire pour lister les voisines d'une cellule (et donc les arÃªtes).

<img src={require('./images/labyrinthe-graphe-sommets.png').default} alt="Arbre binaire" height="250"/> 

Arbre d'un graphe parfait avec sommets-coordonnÃ©es. Les voisins du sommet (2,0) sont (1,0), (2,1) et (3,0). Ceux du sommet (2,1) sont (2,0) et (2,2).

Dans l'exemple prÃ©cÃ©dent, les sommets du graphe sont les cellules :

`(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3)`

Les arÃªtes sont :

`{(0, 0), (1, 0)}, {(1, 0), (2, 0)}, {(2, 0), (3, 0)}, {(2, 0), (2, 1)}, ...`

Les voisinages (les _successeurs_, en quelque sorte) correspondants :

```python
{
    (0, 0): {(1, 0)}, 
    (0, 1): {(0, 2), (1, 1)}, 
    (0, 2): {(0, 1), (0, 3)}, 
    (0, 3): {(0, 2), (1, 3)}, 
    (1, 0): {(2, 0), (0, 0)}, 
    (1, 1): {(0, 1), (1, 2)}, 
    (1, 2): {(1, 1), (2, 2)}, 
    (1, 3): {(2, 3), (0, 3)}, 
    (2, 0): {(1, 0), (2, 1), (3, 0)}, 
    (2, 1): {(2, 0), (2, 2)}, 
    (2, 2): {(1, 2), (2, 1)}, 
    (2, 3): {(3, 3), (1, 3)}, 
    (3, 0): {(3, 1), (2, 0)}, 
    (3, 1): {(3, 2), (3, 0)}, 
    (3, 2): {(3, 1)}, 
    (3, 3): {(2, 3)}
}
```

## ImplÃ©mentation

Nous allons dÃ©finir la classe `Maze` Ã  l'aide des attributs :

- `height`, le nombre de **lignes** (`int`) de la grille du labyrinthe (autrement dit, la hauteur, en nombre de cellules),
- `width`, le nombre de **colonnes** (`int`) de la grille du labyrinthe (autrement dit, la hauteur, en nombre de cellules),
- `neighbors` : un dictionnaire (`dict`) qui associe Ã  chaque cellule, un `set` contenant ses **voisins** (c'est-Ã -dire les cellules qu'on peut atteindre en un dÃ©placement, sans Ãªtre bloquÃ© par un mur).

Voici donc la dÃ©finition sommaire de la classe `Maze`, pour laquelle nous vous fournissons, un constructeur par dÃ©faut, une mÃ©thode d'affichage (en ASCII), et une mÃ©thode qui rÃ©sume les infos du labyrinthe :

```python
"""
Classe Labyrinthe
ReprÃ©sentation sous forme de graphe non-orientÃ©
dont chaque sommet est une cellule (un tuple (l,c))
et dont la structure est reprÃ©sentÃ©e par un dictionnaire
  - clÃ©s : sommets
  - valeurs : ensemble des sommets voisins accessibles
"""
class Maze:
    def __init__(self, height, width):
        """
        Constructeur d'un labyrinthe de height cellules de haut 
        et de width cellules de large 
        Les voisinages sont initialisÃ©s Ã  des ensembles vides
        Remarque : dans le labyrinthe crÃ©Ã©, chaque cellule est complÃ¨tement emmurÃ©e
        """
    self.height = height
    self.width = width
    self.neighbors = {(i,j): set() for i in range(height) for j in range (width)}

    def info(self):
        """
        **NE PAS MODIFIER CETTE MÃ‰THODE**
        Affichage des attributs d'un objet 'Maze' (fonction utile pour deboguer)
        Retour:
            chaÃ®ne (string): description textuelle des attributs de l'objet
        """
        txt = "**Informations sur le labyrinthe**\n"
        txt += f"- Dimensions de la grille : {self.height} x {self.width}\n"
        txt += "- Voisinages :\n"
        txt += str(self.neighbors)+"\n"
        valid = True
        for c1 in {(i, j) for i in range(self.height) for j in range(self.width)}:
            for c2 in self.neighbors[c1]:
                if c1 not in self.neighbors[c2]:
                    valid = False
                    break
            else:
                continue
            break
        txt += "- Structure cohÃ©rente\n" if valid else f"- Structure incohÃ©rente : {c1} X {c2}\n"
        return txt

    def __str__(self):
        """
        **NE PAS MODIFIER CETTE MÃ‰THODE**
        ReprÃ©sentation textuelle d'un objet Maze (en utilisant des caractÃ¨res ascii)
        Retour:
            chaÃ®ne (str) : chaÃ®ne de caractÃ¨res reprÃ©sentant le labyrinthe
        """
        txt = ""
        # PremiÃ¨re ligne
        txt += "â”"
        for j in range(self.width-1):
            txt += "â”â”â”â”³"
        txt += "â”â”â”â”“\n"
        txt += "â”ƒ"
        for j in range(self.width-1):
            txt += "   â”ƒ" if (0,j+1) not in self.neighbors[(0,j)] else "    "
        txt += "   â”ƒ\n"
        # Lignes normales
        for i in range(self.height-1):
            txt += "â”£"
            for j in range(self.width-1):
                txt += "â”â”â”â•‹" if (i+1,j) not in self.neighbors[(i,j)] else "   â•‹"
            txt += "â”â”â”â”«\n" if (i+1,self.width-1) not in self.neighbors[(i,self.width-1)] else "   â”«\n"
            txt += "â”ƒ"
            for j in range(self.width):
                txt += "   â”ƒ" if (i+1,j+1) not in self.neighbors[(i+1,j)] else "    "
            txt += "\n"
        # Bas du tableau
        txt += "â”—"
        for i in range(self.width-1):
            txt += "â”â”â”â”»"
        txt += "â”â”â”â”›\n"
        return txt
```

Exemples d'utilisation :

```python
laby = Maze(4, 4)
print(laby.info())
```
```
**Informations sur le labyrinthe**
    - Dimensions de la grille : 4 x 4
    - Voisinages :
    {(0, 0): set(), (0, 1): set(), (0, 2): set(), (0, 3): set(), (1, 0): set(), (1, 1): set(), (1, 2): set(), (1, 3): set(), (2, 0): set(), (2, 1): set(), (2, 2): set(), (2, 3): set(), (3, 0): set(), (3, 1): set(), (3, 2): set(), (3, 3): set()}
    - Structure cohÃ©rente

    â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
    â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
    â”£â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
    â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
    â”£â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
    â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
    â”£â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
    â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
    â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

Cassons quelques murs en redÃ©finissant manuellement les voisinages des cellules concernÃ©es :

```python
laby.neighbors = {
    (0, 0): {(1, 0)},
    (0, 1): {(0, 2), (1, 1)},
    (0, 2): {(0, 1), (0, 3)},
    (0, 3): {(0, 2), (1, 3)},
    (1, 0): {(2, 0), (0, 0)},
    (1, 1): {(0, 1), (1, 2)},
    (1, 2): {(1, 1), (2, 2)},
    (1, 3): {(2, 3), (0, 3)},
    (2, 0): {(1, 0), (2, 1), (3, 0)},
    (2, 1): {(2, 0), (2, 2)},
    (2, 2): {(1, 2), (2, 1)},
    (2, 3): {(3, 3), (1, 3)},
    (3, 0): {(3, 1), (2, 0)},
    (3, 1): {(3, 2), (3, 0)},
    (3, 2): {(3, 1)},
    (3, 3): {(2, 3)}
}

print(laby)
```

```
    â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
    â”ƒ   â”ƒ           â”ƒ
    â”£   â•‹   â•‹â”â”â”â•‹   â”«
    â”ƒ   â”ƒ       â”ƒ   â”ƒ
    â”£   â•‹â”â”â”â•‹   â•‹   â”«
    â”ƒ           â”ƒ   â”ƒ
    â”£   â•‹â”â”â”â•‹â”â”â”â•‹   â”«
    â”ƒ           â”ƒ   â”ƒ
    â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

Ajoutons maintenant un murs entre la cellule (1,3) et la cellule (2,3) que nous venons de retirer (autrement dit : supprimons une arÃªte que nous avons ajoutÃ©e juste avant) :

```python
laby.neighbors[(1,3)].remove((2,3))
laby.neighbors[(2,3)].remove((1,3))
print(laby)
```
```
    â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
    â”ƒ   â”ƒ           â”ƒ
    â”£   â•‹   â•‹â”â”â”â•‹   â”«
    â”ƒ   â”ƒ       â”ƒ   â”ƒ
    â”£   â•‹â”â”â”â•‹   â•‹â”â”â”â”«
    â”ƒ           â”ƒ   â”ƒ
    â”£   â•‹â”â”â”â•‹â”â”â”â•‹   â”«
    â”ƒ           â”ƒ   â”ƒ
    â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

et cassons-le :

```python
laby.neighbors[(1,3)].add((2, 3))
laby.neighbors[(2,3)].add((1, 3))
print(laby)
```

```
    â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
    â”ƒ   â”ƒ           â”ƒ
    â”£   â•‹   â•‹â”â”â”â•‹   â”«
    â”ƒ   â”ƒ       â”ƒ   â”ƒ
    â”£   â•‹â”â”â”â•‹   â•‹   â”«
    â”ƒ           â”ƒ   â”ƒ
    â”£   â•‹â”â”â”â•‹â”â”â”â•‹   â”«
    â”ƒ           â”ƒ   â”ƒ
    â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

:::danger Attention
Comme vous pouvez le constater dans l'exemple qui prÃ©cÃ¨de :

**Ajouter** un mur entre une cellule c1 et une cellule c2 revient Ã  **diminuer** deux voisinages, d'une cellule chacun ; il faut retirer c1 du voisinage de c2 et retirer c2 du voisinage de c1.

**Casser** un mur entre une cellule c1 et une cellule c2 revient Ã  **augmenter** deux voisinages ; il faut ajouter c1 au voisinage de c2 et ajouter c2 au voisinage de c1.

La mÃ©thode info() fournie teste la cohÃ©rence des voisinages en vÃ©rifiant que, dÃ¨s lors qu'une cellule c1 est dans le voisinage d'une cellule c2, alors c2 est aussi dans le voisinage de c1.

Dans l'exemple qui suit, un mur est ajoutÃ© entre (1,3) et (2,3). Si on a bien retirÃ© (2,3) des voisins de (1,3) on a oubliÃ© de retirer (1,3) des voisins de (2,3).

On constate que le labyrinthe est visiblement bon, toutefois, la mÃ©thode info() dÃ©tecte l'incohÃ©rence entre les cellules concernÃ©es.

```python
laby.neighbors[(1, 3)].remove((2, 3))
print(laby)
print(laby.info())
```

```
    â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
    â”ƒ   â”ƒ           â”ƒ
    â”£   â•‹   â•‹â”â”â”â•‹   â”«
    â”ƒ   â”ƒ       â”ƒ   â”ƒ
    â”£   â•‹â”â”â”â•‹   â•‹â”â”â”â”«
    â”ƒ           â”ƒ   â”ƒ
    â”£   â•‹â”â”â”â•‹â”â”â”â•‹   â”«
    â”ƒ           â”ƒ   â”ƒ
    â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›

    **Informations sur le labyrinthe**
    - Dimensions de la grille : 4 x 4
    - Voisinages :
    {(0, 0): {(1, 0)}, (0, 1): {(1, 1), (0, 2)}, (0, 2): {(0, 1), (0, 3)}, (0, 3): {(0, 2), (1, 3)}, (1, 0): {(2, 0), (0, 0)}, (1, 1): {(0, 1), (1, 2)}, (1, 2): {(1, 1), (2, 2)}, (1, 3): {(0, 3)}, (2, 0): {(1, 0), (2, 1), (3, 0)}, (2, 1): {(2, 0), (2, 2)}, (2, 2): {(1, 2), (2, 1)}, (2, 3): {(3, 3), (1, 3)}, (3, 0): {(3, 1), (2, 0)}, (3, 1): {(3, 2), (3, 0)}, (3, 2): {(3, 1)}, (3, 3): {(2, 3)}}
    - Structure incohÃ©rente : (2, 3) X (1, 3)
```
:::

Corrigeons Ã§a :

```python
laby.neighbors[(2, 3)].remove((1, 3)) 
```

Testons maintenant s'il y a un mur entre deux cellules :

```python
c1 = (1, 3)
c2 = (2, 3)
if c1 in laby.neighbors[c2] and c2 in laby.neighbors[c1]:
    print(f"Il n'y a pas de mur entre {c1} et {c2} car elles sont mutuellement voisines")
elif c1 not in laby.neighbors[c2] and c2 not in laby.neighbors[c1]:
    print(f"Il y a un mur entre {c1} et {c2} car {c1} n'est pas dans le voisinage de {c2} et {c2} n'est pas dans le voisinage de {c1}")
else:
    print(f"Il y a une incohÃ©rence de rÃ©ciprocitÃ© des voisinages de {c1} et {c2}")
```

```md
Il y a un mur entre (1, 3) et (2, 3) car (1, 3) n'est pas dans le voisinage de (2, 3) et (2, 3) n'est pas dans le voisinage de (1, 3)
```

Le mÃªme code permet de tester si on peut accÃ©der Ã  une cellule depuis l'autre et vice-versa :


```python
c1 = (1, 3)
c2 = (2, 3)
if c1 in laby.neighbors[c2] and c2 in laby.neighbors[c1]:
    print(f"{c1} est accessible depuis {c2} et vice-versa")
elif c1 not in laby.neighbors[c2] and c2 not in laby.neighbors[c1]:
    print(f"{c1} n'est pas accessible depuis {c2} et vice-versa")
else:
    print(f"Il y a une incohÃ©rence de rÃ©ciprocitÃ© des voisinages de {c1} et {c2}")
```

```md
(1, 3) n'est pas accessible depuis (2, 3) et vice-versa
```

Parcourons maintenant la grille du labyrinthe pour lister l'ensemble des cellules :

```python
L = []
for i in range(laby.height):
    for j in range(laby.width):
        L.append((i,j))
print(f"Liste des cellules : \n{L}")
```

```md
Liste des cellules : 
[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3)]
```

---

## Manipulation de labyrinthes

Nous allons avoir besoin de mÃ©thodes d'instance essentielles, pour construire et rÃ©soudre ces problÃ¨mes de labyrinthes.

Construisons d'abord, Ã  titre d'exemple, la mÃ©thode `add_wall(c1, c2)` qui ajoute un mur entre entre la cellule `c1` et la cellule `c2`.

Ajouter un mur entre deux cellules revient Ã  couper la possibilitÃ© de se dÃ©placer de l'une Ã  l'autre et inversement. Il s'agit donc de retirer `c1` des voisines de `c2`, et de retirer `c2` des voisines de `c1`.   

Ce qui donne :

```python
def add_wall(c1, c2):
    self.neighbors[c1].remove(c2)
    self.neighbors[c2].remove(c1)
```

Remarque : notez l'usage de `self` ; `self` dÃ©signe l'objet sur lequel sera appliquÃ©e la mÃ©thode ; on peut donc comprendre `self.neighbors[c1].remove(c2)`comme Â«Â retirer c2 des voisins de c1, dans la labyrinthe sur lequel la mÃ©thode `add_wall(C&, c2)` sera appliquÃ©eÂ Â»

:::tip Version robuste

On aurait aussi pu vÃ©rifier que les cellules passÃ©es en paramÃ¨tres ont des coordonnÃ©es cohÃ©rentes avec la grille, et que les cellules sont bien voisines l'une de l'autre :

```python
def add_wall(self, c1, c2):
    # Facultatif : on teste si les sommets sont bien dans le labyrinthe
    assert 0 <= c1[0] < self.height and \
        0 <= c1[1] < self.width and \
        0 <= c2[0] < self.height and \
        0 <= c2[1] < self.width, \
        f"Erreur lors de l'ajout d'un mur entre {c1} et {c2} : les coordonnÃ©es de sont pas compatibles avec les dimensions du labyrinthe"
    # Ajout du mur
    if c2 in self.neighbors[c1]:      # Si c2 est dans les voisines de c1
        self.neighbors[c1].remove(c2) # on le retire
    if c1 in self.neighbors[c2]:      # Si c3 est dans les voisines de c2
        self.neighbors[c2].remove(c1) # on le retire
```
:::

Exemple d'utilisation :

```python
laby = Maze(1, 2)
print(laby)
```

```md
â”â”â”â”â”³â”â”â”â”“
â”ƒ   â”ƒ   â”ƒ
â”—â”â”â”â”»â”â”â”â”›
```

```python
laby.neighbors[(0, 0)].add((0, 1))
laby.neighbors[(0, 1)].add((0, 0))
print(laby)
```

```md
â”â”â”â”â”³â”â”â”â”“
â”ƒ       â”ƒ
â”—â”â”â”â”»â”â”â”â”›
```

```python
laby.add_wall((0, 0), (0, 1))
print(laby)
```

```md
â”â”â”â”â”³â”â”â”â”“
â”ƒ   â”ƒ   â”ƒ
â”—â”â”â”â”»â”â”â”â”›
```

::::note A faire

Ã‰crire les mÃ©thodes d'instance suivantes :

- `remove_wall(c1, c2)` qui supprime un mur entre deux cellules ğŸŒ¶ï¸
- `get_all_walls()` qui retourne la liste de **tous les murs** sous la forme d'une liste de `tuple` de cellules ğŸŒ¶ï¸
- `get_contiguous_cells(c)` qui retourne la liste des cellules contigÃ¼es Ã  `c` **dans la grille** (sans s'occuper des Ã©ventuels murs) ğŸŒ¶ï¸ ğŸŒ¶ï¸
- `get_reachable_cells(c)` qui retourne la liste des cellules accessibles depuis `c` (c'est-Ã -dire les cellules contiguÃ«s Ã  c qui sont dans le voisinage de c) ğŸŒ¶ï¸ ğŸŒ¶ï¸

<details>
  <summary>Indications (cliquer pour voir)</summary>
1. Pour simplifier l'Ã©criture de ces mÃ©thodes, vous pourriez en Ã©crire une qui retourne la liste de toutes les cellules de la grille du labyrinthe : `get_all_cells()`.

```
- Soit L la liste des cellules (initialiser L Ã  _vide_)
- Pour tout i allant de 0 Ã  height-1:
    - Pour tout j allant de 0 Ã  width-1:
        - Ajouter (i, j) Ã  L
- Retourner L
```

2. Un algorithme possible pour `get_all_walls(c1)` pourrait Ãªtre :

```
- Soit L la liste des murs (initialiser L Ã  _vide_)
- Pour chaque cellule c1 de la grille :
    - Si la cellule c2 Ã  droite de c1 est dans la grille **et** qu'elle n'est pas dans les voisines de c1:
        - Ajouter le mur [c1, c2] Ã  L
    - Si la cellule c3 en dessous de c1 est dans la grille **et** qu'elle n'est pas dans les voisines de c1:
        - Ajouter le mur [c1, c3] Ã  L
- Retourner L
```

3. Les cellules contiguÃ«s (retournÃ©es par `get_contiguous(c1)`) d'une cellule $(i,j)$ (notÃ©e c1 ici) sont les cellules :

-   $(i-1, j)$ si $i-1 >= 0$
-   $(i+1, j)$ si $i+1 < \text{height}$
-   $(i, j-1)$ si $j-1 >= 0$
-   $(i, j+1)$ si $j+1 < \text{width}$

4. Les cellules atteignables (retournÃ©es par `get_reachable(c1)`) depuis une cellule $(i,j)$ (notÃ©e c1 ici) sont les cellules :

-   contiguÃ«s Ã  $(i,j)$
-   et qui ne sont pas sÃ©parÃ©es de $(i,j)$ par un mur

</details>
Exemple d'utilisation de ces mÃ©thodes :

```python	
laby = Maze(5, 5)
print(laby)
```

```md
â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

```python
laby.remove_wall((0, 0), (0, 1))
print(laby)
```

```md
â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
â”ƒ       â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

```python
laby.empty()
laby.add_wall((0, 0), (0, 1))
laby.add_wall((0, 1), (1, 1))
print(laby)
```

```md
â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
â”ƒ   â”ƒ               â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹   â•‹   â”«
â”ƒ                   â”ƒ
â”£   â•‹   â•‹   â•‹   â•‹   â”«
â”ƒ                   â”ƒ
â”£   â•‹   â•‹   â•‹   â•‹   â”«
â”ƒ                   â”ƒ
â”£   â•‹   â•‹   â•‹   â•‹   â”«
â”ƒ                   â”ƒ
â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

```python
print(laby.get_all_walls())
```

```md
[[(0, 0), (0, 1)], [(0, 1), (1, 1)]]
```

```python
print(laby.get_contiguous_cells((0,1)))
```

```md
[(1, 1), (0, 0), (0, 2)]
```

```python
print(laby.get_reachable_cells((0,1)))
```

```md
[(0, 2)]
```
::::

---

## GÃ©nÃ©ration

Nous allons maintenant nous intÃ©resser aux algorithmes permettant de gÃ©nÃ©rer des labyrinthes parfaits.

Nous allons commencer par implÃ©menter deux classiques assez simples, l'un reposant sur les arbres binaires et le second, appelÃ© *sidewinder*. Nous verrons aussi deux algorithmes un peu plus avancÃ©s, qu'on retrouve notamment dans [l'article wikipedia consacrÃ© Ã  la modÃ©lisation mathÃ©matique des labyrinthes](https://fr.wikipedia.org/wiki/Mod%C3%A9lisation_math%C3%A9matique_d%27un_labyrinthe) :

- l'algorithme de gÃ©nÃ©ration par **fusion de chemins** (qui peut-Ãªtre vu comme une forme de l'algorithme de Kruskal, qui permet de dÃ©terminer un **arbre couvrant de poids minimal** dans un graphe non-orientÃ© valuÃ©)
- l'algorithme de gÃ©nÃ©ration par **exploration exhaustive** (qui utilise un parcours de graphe, en profondeur ou en largeur)

On terminera par l'algorithme de Wilson.

:::info MÃ©thode de classe

Les mÃ©thodes de gÃ©nÃ©rations seront implÃ©mentÃ©es comme des mÃ©thodes de classe. Comme leur nom l'indique les mÃ©thodes de classes s'appliquent au nom de la classe (`Maze`) et pas Ã  une instance (`laby` par exemple).

Pour dÃ©finir une mÃ©thode de classe en python, il est nÃ©cessaire de faire prÃ©cÃ©der la dÃ©finition de la mÃ©thode par le dÃ©corateur `@classmethod`, et Ã  remplacer `self` par `cls` :

```python	
@classmethod
def ma_methode_de_classe(cls, param1, param2):
    #
    #
    #


ma_classe.ma_methode_de_classe(p1, p2)
```

Exemples :
```python
laby = Maze.gen_btree(4, 4)
print(laby)
```

```md
â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
â”ƒ   â”ƒ       â”ƒ   â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ       â”ƒ   â”ƒ   â”ƒ
â”£â”â”â”â•‹   â•‹   â•‹   â”«
â”ƒ   â”ƒ           â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹   â”«
â”ƒ               â”ƒ
â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

:::

### Arbre binaire 

L'algorithme de gÃ©nÃ©ration par arbre binaire consiste Ã  gÃ©nÃ©rerâ€¦ un arbre binaire comme support du labyrinthe.

La procÃ©dure est assez simple :

:::danger Algorithme de construction par arbre binaire

- Initialisation : un labyrinthe plein (contenant tous les murs possibles)
- Pour chaque cellule du labyrinthe :
  - Supprimer alÃ©atoirement le mur EST ou le mur SUD (s'il n'en possÃ¨de qu'un, supprimer ce mur ; s'il n'en possÃ¨de aucun des deux, ne rien faire)

:::

**Remarque :** on utilisera dans la suite de ce document les points cardinaux (NORD, SUD, EST, OUEST) pour l'orientation sur la grille.

:::note A faire

Ã‰crire une mÃ©thode de classe `gen_btree(h, w)` qui gÃ©nÃ¨re un labyrinthe Ã  $h$ lignes et $w$ colonnes, en utilisant l'algorithme de construction par arbre binaire. ğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸

:::

### Sidewinder

L'algorithme de gÃ©nÃ©ration sidewinder ressemble beaucoup au prÃ©cÃ©dent. L'idÃ©e est de procÃ©der ligne par ligne, d'OUEST en EST, en choisissant alÃ©atoirement de casser le mur EST d'une cellule. Pour chaque sÃ©quence de cellules voisines (connectÃ©es) crÃ©Ã©e sur la ligne, on casse un mur SUD au hasard d'une de ces cellules (une sÃ©quence peut Ãªtre constituÃ©e d'une seule cellule).

On pourrait formaliser le pseudo code de la faÃ§on suivante :

:::danger Algorithme sidewinder

- Initialisation : crÃ©ation d'un labyrinthe plein
- Pour i allant de 0 Ã  hauteur-2 :
  - Initialiser une variable sÃ©quence comme liste vide
  - Pour j allant de 0 Ã  largeur-2 :
    - Ajouter la cellule $(i, j)$ Ã  la sÃ©quence
    - Tirer Ã  pile ou face :
      - Si c'est pile : Casser le mur EST de la cellule $(i, j)$
      - Si c'est face :
        - Casser le mur SUD d'une des cellules (choisie au hasard) qui constituent le sÃ©quence qui vient d'Ãªtre terminÃ©e.
        - RÃ©initialiser la sÃ©quence Ã  une liste vide
  - Ajouter la derniÃ¨re cellule Ã  la sÃ©quence
  - Tirer une cellule au sort dans la sÃ©quence et casser son mur SUD
- Casser tous les murs EST de la derniÃ¨re ligne
- Retourner le labyrinthe

:::

:::note A faire

Ã‰crire une mÃ©thode de classe `gen_sidewinder(h, w)` qui gÃ©nÃ¨re une labyrinthe Ã  $h$ lignes et $w$ colonnes, en utilisant l'algorithme de construction sidewinder.ğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸

:::

```python
laby = Maze.gen_sidewinder(4, 4)
print(laby)
```

```md
â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
â”ƒ       â”ƒ   â”ƒ   â”ƒ
â”£â”â”â”â•‹   â•‹   â•‹   â”«
â”ƒ       â”ƒ       â”ƒ
â”£â”â”â”â•‹   â•‹â”â”â”â•‹   â”«
â”ƒ       â”ƒ   â”ƒ   â”ƒ
â”£â”â”â”â•‹   â•‹   â•‹   â”«
â”ƒ               â”ƒ
â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

:::info Note

Si vous essayez les gÃ©nÃ©rateurs prÃ©cÃ©dents plusieurs fois, vous devriez observer des _patterns_ (au delÃ  de la derniÃ¨re ligne, qui est un dÃ©faut Ã©vident). Ces caractÃ©ristiques sont des dÃ©fauts majeurs pour un labyrinthe.

:::

### Fusion de chemins

L'algorithme de fusion de chemins consiste Ã  partir d'un labyrinthe Â« plein Â», puis Ã  casser des murs au hasard en Ã©vitant de crÃ©er des cycles. Puisqu'un labyrinthe parfait est un arbre, et qu'un arbre Ã  sommets a exactement $n - 1$ arÃªtes, il suffit d'abattre $n - 1$ murs (soit $h \times w - 1$ si $h$ et $w$ donnent respectivement le nombre de lignes et le nombre de colonnes).

Pour Ã©viter de crÃ©er des cycles, on utilise un mÃ©canisme de labÃ©lisation des cellules (avec des entiers). Lorsqu'on casse un mur depuis une cellule, le label de la cellule Â« se propage Â» dans la zone dÃ©couverte. Mais on n'ouvrira un mur que lorsque le label de la cellule courante est diffÃ©rent du label de la cellule qui est de l'autre cÃ´tÃ© du mur.

Voici la description de l'algorithme :

:::danger Algorithme par fusion de chemins

- Initialisation :
  - on remplit le labyrinthe avec tous les murs possibles
  - on labÃ©lise les cellules de 1 Ã  $n$
  - on extrait la liste de tous les murs et on les Â«&nbsp;mÃ©lange Â» (on les permute alÃ©atoirement)
- Pour chaque mur de la liste :
  - Si les deux cellules sÃ©parÃ©es par le mur n'ont pas le mÃªme label :
    - casser le mur
    - affecter le label de l'une des deux cellules, Ã  l'autre, et Ã  toutes celles qui ont le mÃªme label que la deuxiÃ¨me

:::

![](https://upload.wikimedia.org/wikipedia/commons/6/69/Yl_maze_ani_algo1.gif)

Illustration animÃ©e issue de [l'article wikipedia consacrÃ© Ã  la modÃ©lisation mathÃ©matique des labyrinthes](https://fr.wikipedia.org/wiki/Mod%C3%A9lisation_math%C3%A9matique_d%27un_labyrinthe#)

:::note A faire

Ã‰crire une mÃ©thode de classe `gen_fusion(h,w)` qui gÃ©nÃ¨re un labyrinthe, Ã  $h$ lignes et $w$ colonnes, parfait, avec l'algorithme de fusion de chemins. ğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸

Exemple :

```python
laby = Maze.gen_fusion(15,15)
print(laby)
```

```md
â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
â”ƒ   â”ƒ   â”ƒ       â”ƒ               â”ƒ   â”ƒ           â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”£   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹   â”«
â”ƒ       â”ƒ           â”ƒ   â”ƒ           â”ƒ       â”ƒ   â”ƒ           â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â”«
â”ƒ       â”ƒ   â”ƒ   â”ƒ       â”ƒ       â”ƒ       â”ƒ           â”ƒ   â”ƒ   â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ               â”ƒ           â”ƒ           â”ƒ   â”ƒ               â”ƒ
â”£â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ           â”ƒ       â”ƒ   â”ƒ       â”ƒ   â”ƒ   â”ƒ   â”ƒ       â”ƒ       â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â”«
â”ƒ   â”ƒ       â”ƒ                       â”ƒ           â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â”«
â”ƒ               â”ƒ   â”ƒ   â”ƒ           â”ƒ       â”ƒ               â”ƒ
â”£â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â”«
â”ƒ   â”ƒ   â”ƒ   â”ƒ       â”ƒ   â”ƒ           â”ƒ       â”ƒ       â”ƒ   â”ƒ   â”ƒ
â”£   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â”«
â”ƒ       â”ƒ       â”ƒ   â”ƒ       â”ƒ           â”ƒ   â”ƒ       â”ƒ       â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â”«
â”ƒ       â”ƒ       â”ƒ       â”ƒ   â”ƒ           â”ƒ               â”ƒ   â”ƒ
â”£   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â”«
â”ƒ   â”ƒ       â”ƒ       â”ƒ   â”ƒ   â”ƒ       â”ƒ   â”ƒ       â”ƒ   â”ƒ       â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â”«
â”ƒ   â”ƒ       â”ƒ       â”ƒ   â”ƒ           â”ƒ                       â”ƒ
â”£   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ           â”ƒ   â”ƒ       â”ƒ                   â”ƒ               â”ƒ
â”£   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â”«
â”ƒ   â”ƒ   â”ƒ   â”ƒ       â”ƒ               â”ƒ       â”ƒ   â”ƒ   â”ƒ       â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ   â”ƒ           â”ƒ       â”ƒ               â”ƒ               â”ƒ   â”ƒ
â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```
:::

### Exploration exhaustive

Une deuxiÃ¨me idÃ©e consiste Ã  Â« explorer Â» alÃ©atoirement le labyrinthe, Ã  la maniÃ¨re d'un parcours en profondeur, en cassant les murs Ã  mesure qu'on avance :

:::danger Algorithme de gÃ©nÃ©ration par exploration

- Initialisation :
  - Choisir une cellule au hasard
  - Marquer cette cellule comme Ã©tant visitÃ©e
  - Mettre cette cellule dans sur une pile
- Tant qu'il reste des cellules non-marquÃ©es :
  - Prendre la cellule en haut de la pile et l'en retirer
  - Si cette cellule a des voisins qui n'ont pas encore Ã©tÃ© visitÃ©s :
    - La remettre sur la pile
    - Choisir au hasard l'une de ses cellules contigÃ¼es qui n'a pas Ã©tÃ© visitÃ©e
    - Casser le mur entre la cellule (celle qui a Ã©tÃ© dÃ©pilÃ©e) et celle qui vient d'Ãªtre choisie
    - Marquer la cellule qui vient d'Ãªtre choisie comme visitÃ©e
    - Et la mettre sur la pile

:::

![](https://upload.wikimedia.org/wikipedia/commons/b/b3/Yl_maze_ani_algo2.gif)

Illustration animÃ©e issue de [l'article wikipedia consacrÃ© Ã  la modÃ©lisation mathÃ©matique des labyrinthes](https://fr.wikipedia.org/wiki/Mod%C3%A9lisation_math%C3%A9matique_d%27un_labyrinthe#)

:::note A faire

Ã‰crire une mÃ©thode de classe `gen_exploration(h,w)` qui gÃ©nÃ¨re un labyrinthe, Ã  $h$ lignes et $w$ colonnes, parfait, avec l'algorithme d'exploration exhaustive. ğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸

Exemple :

```python
laby = Maze.gen_exploration(15,15)
print(laby)
```

```md
â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
â”ƒ               â”ƒ                                   â”ƒ       â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â”«
â”ƒ   â”ƒ       â”ƒ   â”ƒ   â”ƒ       â”ƒ           â”ƒ   â”ƒ       â”ƒ       â”ƒ
â”£   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ       â”ƒ       â”ƒ   â”ƒ   â”ƒ               â”ƒ   â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â”«
â”ƒ       â”ƒ   â”ƒ       â”ƒ       â”ƒ       â”ƒ               â”ƒ   â”ƒ   â”ƒ
â”£   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â”«
â”ƒ   â”ƒ   â”ƒ           â”ƒ           â”ƒ   â”ƒ       â”ƒ       â”ƒ       â”ƒ
â”£â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â”«
â”ƒ       â”ƒ   â”ƒ   â”ƒ           â”ƒ   â”ƒ   â”ƒ           â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â”«
â”ƒ   â”ƒ       â”ƒ                   â”ƒ       â”ƒ   â”ƒ       â”ƒ       â”ƒ
â”£   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â”«
â”ƒ   â”ƒ           â”ƒ           â”ƒ   â”ƒ               â”ƒ           â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ   â”ƒ               â”ƒ       â”ƒ   â”ƒ   â”ƒ       â”ƒ               â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â”«
â”ƒ           â”ƒ       â”ƒ   â”ƒ       â”ƒ       â”ƒ                   â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â”«
â”ƒ       â”ƒ           â”ƒ                           â”ƒ       â”ƒ   â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â”«
â”ƒ       â”ƒ           â”ƒ           â”ƒ                   â”ƒ   â”ƒ   â”ƒ
â”£   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ   â”ƒ   â”ƒ       â”ƒ   â”ƒ       â”ƒ   â”ƒ           â”ƒ       â”ƒ   â”ƒ   â”ƒ
â”£â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ           â”ƒ       â”ƒ   â”ƒ   â”ƒ       â”ƒ   â”ƒ   â”ƒ   â”ƒ       â”ƒ   â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â”«
â”ƒ                       â”ƒ               â”ƒ       â”ƒ           â”ƒ
â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

:::

### L'algorithme de Wilson

Terminons avec un algorithme plus amusant, qui donne des labyrinthes trÃ¨s intÃ©ressants : l'algorithme de Wilson. Il repose sur les _marches alÃ©atoires_.

L'idÃ©e est la suivante : on va construire le labyrinthe en essayant des chemins alÃ©atoires, jusqu'Ã  obtention d'une arborescenceâ€¦

:::danger Algorithme de Wilson

- Choisir une cellule au hasard sur la grille et la marquer
- Tant qu'il reste des cellules non marquÃ©es :
  - Choisir une cellule de dÃ©part au hasard, parmi les cellules non marquÃ©es
  - Effectuer une marche alÃ©atoire jusqu'Ã  ce qu'une cellule marquÃ©e soit atteinte (en cas de boucle, si la tÃªte du _snake_ se mord la queue, Â« couper Â» la boucle formÃ©e [autrement dit, supprimer toutes Ã©tapes depuis le prÃ©cÃ©dent passage])
  - Marquer chaque cellule du chemin, et casser tous les murs rencontrÃ©s, jusqu'Ã  la cellule marquÃ©e

:::

:::note A faire

Ã‰crire une mÃ©thode de classe `gen_wilson(h, w)` qui implÃ©mente cet algorithme. ğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸

Exemple :

```python
laby = Maze.gen_wilson(12, 12)
print(laby)
```

```md
â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
â”ƒ   â”ƒ       â”ƒ   â”ƒ   â”ƒ                           â”ƒ
â”£   â•‹   â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â”«
â”ƒ       â”ƒ               â”ƒ       â”ƒ   â”ƒ       â”ƒ   â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â”«
â”ƒ       â”ƒ   â”ƒ   â”ƒ   â”ƒ           â”ƒ       â”ƒ       â”ƒ
â”£   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â”«
â”ƒ   â”ƒ           â”ƒ   â”ƒ           â”ƒ   â”ƒ       â”ƒ   â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â”«
â”ƒ       â”ƒ   â”ƒ           â”ƒ                   â”ƒ   â”ƒ
â”£â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ   â”ƒ   â”ƒ           â”ƒ       â”ƒ   â”ƒ       â”ƒ       â”ƒ
â”£   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â”«
â”ƒ           â”ƒ   â”ƒ                   â”ƒ           â”ƒ
â”£â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ           â”ƒ       â”ƒ                   â”ƒ   â”ƒ   â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ   â”ƒ           â”ƒ               â”ƒ   â”ƒ       â”ƒ   â”ƒ
â”£   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â”«
â”ƒ   â”ƒ   â”ƒ               â”ƒ       â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â”«
â”ƒ           â”ƒ   â”ƒ   â”ƒ   â”ƒ                       â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â”«
â”ƒ                       â”ƒ           â”ƒ   â”ƒ       â”ƒ
â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```
:::

---

## RÃ©solution

Avant d'Ã©crire des mÃ©thodes de rÃ©solution de labyrinthe, ajoutez cette mÃ©thode Ã  votre classe Maze :

```python	
def overlay(self, content=None):
    """
    Rendu en mode texte, sur la sortie standard, \
    d'un labyrinthe avec du contenu dans les cellules
    Argument:
        content (dict) : dictionnaire tq content[cell] contient le caractÃ¨re Ã  afficher au milieu de la cellule
    Retour:
        string
    """
    if content is None:
        content = {(i,j):' ' for i in range(self.height) for j in range(self.width)}
    else:
        # Python >=3.9
        #content = content | {(i, j): ' ' for i in range(
        #    self.height) for j in range(self.width) if (i,j) not in content}
        # Python <3.9
        new_content = {(i, j): ' ' for i in range(self.height) for j in range(self.width) if (i,j) not in content}
        content = {**content, **new_content}
    txt = r""
    # PremiÃ¨re ligne
    txt += "â”"
    for j in range(self.width-1):
        txt += "â”â”â”â”³"
    txt += "â”â”â”â”“\n"
    txt += "â”ƒ"
    for j in range(self.width-1):
        txt += " "+content[(0,j)]+" â”ƒ" if (0,j+1) not in self.neighbors[(0,j)] else " "+content[(0,j)]+"  "
    txt += " "+content[(0,self.width-1)]+" â”ƒ\n"
    # Lignes normales
    for i in range(self.height-1):
        txt += "â”£"
        for j in range(self.width-1):
            txt += "â”â”â”â•‹" if (i+1,j) not in self.neighbors[(i,j)] else "   â•‹"
        txt += "â”â”â”â”«\n" if (i+1,self.width-1) not in self.neighbors[(i,self.width-1)] else "   â”«\n"
        txt += "â”ƒ"
        for j in range(self.width):
            txt += " "+content[(i+1,j)]+" â”ƒ" if (i+1,j+1) not in self.neighbors[(i+1,j)] else " "+content[(i+1,j)]+"  "
        txt += "\n"
    # Bas du tableau
    txt += "â”—"
    for i in range(self.width-1):
        txt += "â”â”â”â”»"
    txt += "â”â”â”â”›\n"
    return txt
```

Cette mÃ©thode permettra d'afficher un labyrinthe en mode texte en lui ajoutant des caractÃ¨res dans les cellules (afin de visualiser les solutions trouvÃ©es, par exemple). Il suffit pour Ã§a de fournir Ã  `overlay` un dictionnaire `content` dont les clÃ©s sont des cellules et les valeurs sont les caractÃ¨res Ã  afficher dans les cellules correspondantes.

Exemples :

```python
laby = Maze(4,4)
laby.empty()
print(laby.overlay({
    (0, 0):'c',
    (0, 1):'o',
    (1, 1):'u',
    (2, 1):'c',
    (2, 2):'o',
    (3, 2):'u',
    (3, 3):'!'}))
```

```md
â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
â”ƒ c   o         â”ƒ
â”£   â•‹   â•‹   â•‹   â”«
â”ƒ     u         â”ƒ
â”£   â•‹   â•‹   â•‹   â”«
â”ƒ     c   o     â”ƒ
â”£   â•‹   â•‹   â•‹   â”«
â”ƒ         u   ! â”ƒ
â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

```python
laby = Maze(4,4)
laby.empty()
path = {(0, 0): '@',
        (1, 0): '*',
        (1, 1): '*',
        (2, 1): '*',
        (2, 2): '*',
        (3, 2): '*',
        (3, 3): 'Â§'}
print(laby.overlay(path))
```

```md
â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
â”ƒ @             â”ƒ
â”£   â•‹   â•‹   â•‹   â”«
â”ƒ *   *         â”ƒ
â”£   â•‹   â•‹   â•‹   â”«
â”ƒ     *   *     â”ƒ
â”£   â•‹   â•‹   â•‹   â”«
â”ƒ         *   Â§ â”ƒ
â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

### RÃ©solution par parcours

L'algorithme le plus Ã©vident pour rÃ©soudre un problÃ¨me de labyrinthe, consiste Ã  adapter le parcours Â« en profondeur d'abord Â» de l'arborescence associÃ©e au labyrinthe :

:::danger Algorithme de rÃ©solution par parcours (pour aller de la cellule D Ã  la cellule A)

**Parcours du graphe jusqu'Ã  ce qu'on trouve A**

- Initialisation :
  - Placer D dans la struture d'attente (file ou pile) et marquer D
  - MÃ©moriser l'Ã©lÃ©ment prÃ©dÃ©cesseur de D comme Ã©tant D
- Tant qu'il reste des cellules non-marquÃ©es :
  - Prendre la Â« premiÃ¨re Â» cellule et la retirer de la structure (appelons c, cette cellule)
  - Si c correspond Ã  A :
    - C'est terminÃ©, on a trouvÃ© un chemin vers la cellule de destination
  - Sinon :
    - Pour chaque voisin de c :
      - Si elle n'est pas marquÃ©e :
        - La marquer
        - La mettre dans la structure d'attente
        - MÃ©moriser son prÃ©dÃ©cesseur comme Ã©tant c

**Reconstruction du chemin Ã  partir des prÃ©dÃ©cesseurs**

- Initialier c Ã  A
- Tant que c n'est pas D :
  - ajouter c au chemin
  - mettre le prÃ©dÃ©cesseur de c dans c
- Ajouter D au chemin

Retourner le chemin

:::

::::note A faire

ImplÃ©menter cet algorithme dans une mÃ©thode d'instance `solve_dfs(start, stop)` ğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸ qui prend la cellule de dÃ©part et la cellule d'arrivÃ©e comme arguments. CrÃ©er ensuite une mÃ©thode `solve_bfs(start, stop)` ğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸ qui implÃ©mente cette fois un parcours en largeurğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸

<details>
  <summary>Indications/rappels</summary>
  - Si vous choisissez une file comme structure d'attente, il s'agit du parcours en largeur ; si vous prenez une pile, il s'agit d'un parcours en profondeur.
  - Un chemin est simplement une succession de cellules. On pourra la reprÃ©senter avec une liste (ou un tuple), constituÃ©e des tuples des cellules.
  - Pour mÃ©moriser les prÃ©dÃ©cesseurs, on utilisera un dictionnaire `pred` dont chaque clÃ© est une cellule et chaque valeur Ã©galement.
</details>

Exemples :

```python
laby = Maze.gen_fusion(15, 15)
solution = laby.solve_dfs((0, 0), (14, 14))
str_solution = {c:'*' for c in solution}
str_solution[( 0,  0)] = 'D'
str_solution[(14, 14)] = 'A'
print(laby.overlay(str_solution))
```

```md
â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
â”ƒ D     â”ƒ   â”ƒ               â”ƒ       â”ƒ   â”ƒ       â”ƒ           â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ * â”ƒ                       â”ƒ   â”ƒ                   â”ƒ       â”ƒ
â”£   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â”«
â”ƒ *     â”ƒ   â”ƒ   â”ƒ           â”ƒ               â”ƒ               â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â”«
â”ƒ *   *   *   *   *   *   *     â”ƒ *   * â”ƒ   â”ƒ   â”ƒ       â”ƒ   â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â”«
â”ƒ               â”ƒ   â”ƒ   â”ƒ *   *   * â”ƒ * â”ƒ   â”ƒ   â”ƒ   â”ƒ       â”ƒ
â”£   â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â”«
â”ƒ   â”ƒ   â”ƒ   â”ƒ       â”ƒ           â”ƒ   â”ƒ *     â”ƒ   â”ƒ       â”ƒ   â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ           â”ƒ   â”ƒ       â”ƒ   â”ƒ   â”ƒ   â”ƒ * â”ƒ   â”ƒ           â”ƒ   â”ƒ
â”£â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â”«
â”ƒ           â”ƒ   â”ƒ   â”ƒ   â”ƒ       â”ƒ   â”ƒ *     â”ƒ       â”ƒ   â”ƒ   â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â”«
â”ƒ       â”ƒ   â”ƒ       â”ƒ           â”ƒ *   * â”ƒ                   â”ƒ
â”£   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ   â”ƒ           â”ƒ   â”ƒ             *     â”ƒ   â”ƒ               â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â”«
â”ƒ       â”ƒ   â”ƒ   â”ƒ       â”ƒ   â”ƒ   â”ƒ *     â”ƒ             *   * â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â”«
â”ƒ       â”ƒ           â”ƒ   â”ƒ   â”ƒ     *     â”ƒ   â”ƒ   â”ƒ   â”ƒ * â”ƒ * â”ƒ
â”£â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹   â”«
â”ƒ       â”ƒ       â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ *   * â”ƒ       â”ƒ   â”ƒ * â”ƒ * â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ                   â”ƒ       â”ƒ         * â”ƒ       â”ƒ     * â”ƒ * â”ƒ
â”£   â•‹   â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ   â”ƒ             *   *   *   *   * â”ƒ A â”ƒ
â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

```python
laby = Maze.gen_exploration(15, 15)
solution = laby.solve_bfs((0, 0), (14, 14))
str_solution = {c:'*' for c in solution}
str_solution[( 0,  0)] = 'D'
str_solution[(14, 14)] = 'A'
print(laby.overlay(str_solution))
```

```md
â”â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”³â”â”â”â”“
â”ƒ D   *   *   *   *         â”ƒ *   *     â”ƒ *   * â”ƒ *   *   * â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â”«
â”ƒ   â”ƒ *   *   *   * â”ƒ   â”ƒ *   * â”ƒ *   *   * â”ƒ *   *     â”ƒ * â”ƒ
â”£   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â”«
â”ƒ   â”ƒ *   *   *   * â”ƒ   â”ƒ *   *   * â”ƒ     *   * â”ƒ *   *   * â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â”«
â”ƒ       â”ƒ       â”ƒ *   *   *   * â”ƒ * â”ƒ   â”ƒ * â”ƒ * â”ƒ *   * â”ƒ   â”ƒ
â”£â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â”«
â”ƒ   â”ƒ       â”ƒ           â”ƒ *   * â”ƒ *   *   * â”ƒ *     â”ƒ *   * â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â”«
â”ƒ               â”ƒ   â”ƒ   â”ƒ * â”ƒ               â”ƒ * â”ƒ *   * â”ƒ * â”ƒ
â”£â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â”«
â”ƒ           â”ƒ       â”ƒ   â”ƒ *   *   *   *   *   * â”ƒ * â”ƒ * â”ƒ * â”ƒ
â”£   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â”«
â”ƒ   â”ƒ   â”ƒ               â”ƒ *   *   *   *   * â”ƒ *   * â”ƒ * â”ƒ * â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ   â”ƒ       â”ƒ           â”ƒ *   *   *   * â”ƒ *   * â”ƒ     *   * â”ƒ
â”£   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â”«
â”ƒ   â”ƒ       â”ƒ   â”ƒ       â”ƒ           â”ƒ * â”ƒ *   *   * â”ƒ       â”ƒ
â”£   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â”«
â”ƒ       â”ƒ       â”ƒ       â”ƒ   â”ƒ   â”ƒ   â”ƒ *   * â”ƒ *   * â”ƒ       â”ƒ
â”£â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â”«
â”ƒ                   â”ƒ           â”ƒ   â”ƒ   â”ƒ *   * â”ƒ *   * â”ƒ   â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹   â•‹   â•‹   â•‹â”â”â”â”«
â”ƒ   â”ƒ           â”ƒ               â”ƒ       â”ƒ * â”ƒ   â”ƒ * â”ƒ *   * â”ƒ
â”£   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹   â”«
â”ƒ   â”ƒ       â”ƒ   â”ƒ       â”ƒ   â”ƒ       â”ƒ   â”ƒ *   *   * â”ƒ     * â”ƒ
â”£   â•‹   â•‹   â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â•‹   â•‹â”â”â”â•‹   â•‹â”â”â”â•‹â”â”â”â•‹â”â”â”â•‹   â•‹   â”«
â”ƒ       â”ƒ                   â”ƒ           â”ƒ               â”ƒ A â”ƒ
â”—â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”»â”â”â”â”›
```

### RÃ©solution en aveugle : Â« la main droite Â»

L'algorithme, bien connu, dit Â« de la main droite Â» peut-Ãªtre vu comme une recherche Â« en profondeur d'abord Â» mais sans vision globale du labyrinthe. C'est la situation dans laquelle serait un individu qu'on abandonnerait dans un labyrinthe et qui devrait trouver la sortie. Il consiste Ã  longer les murs en ayant toujours un contact avec un mur sur notre droite.
:::note A faire

ImplÃ©menter cet algorithme dans une mÃ©thode d'instance `solve_rhr(start, stop)` qui retourne le chemin trouvÃ© pour aller de `start` Ã  `stop`. ğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸ğŸŒ¶ï¸
::::

---

## Ã‰valuation

Nous sommes dÃ©sormais capables de gÃ©nÃ©rer des labyrinthes parfaits, et de les rÃ©soudre.

Il nous faudrait maintenant quelques outils d'Ã©valuation des labyrinthes produits :

- le labyrinthe gÃ©nÃ©rÃ© est-il Â« facile Â» ?
- la meilleure solution est-elle longue Ã  trouver (relativement aux points de dÃ©part et d'arrivÃ©e) ?

:::note A faire

Ã‰crire une mÃ©thode d'instance `distance_geo(c1, c2)` qui calcule la distance Â« gÃ©odÃ©sique Â» entre la cellule `c1` et la cellule `c2` (vous pourrez utiliser une des mÃ©thodes de rÃ©solution implÃ©mentÃ©es avant), c'est Ã  dire le nombre minimal de dÃ©placements nÃ©cessaires sur le graphe pour aller de `c1` Ã  `c2`.ğŸŒ¶ï¸

Ã‰crire une mÃ©thode d'instance `distance_man(c1, c2)` qui calcule la distance de Manhattan, `h` sur la grille, entre la cellule `c1` et la cellule `c2`, c'est Ã  dire le nombre minimal de dÃ©placements nÃ©cessaires pour aller de `c2` Ã  `c1` si le labyrinthe Ã©tait vide de tout mur.ğŸŒ¶ï¸

Ã‰crire une mÃ©thode d'instance `worst_path_len()` qui retourne la longueur du plus long chemin menant du dÃ©part Ã  une impasse (une feuille).ğŸŒ¶ï¸ğŸŒ¶ï¸

Ã‰crire une mÃ©thode d'instance `dead_end_number()` qui retourne le nombre de culs-de-sacs prÃ©sents dans le labyrinthe.ğŸŒ¶ï¸ğŸŒ¶ï¸
:::

---

## Du problÃ¨me algorithmique au _rogue_ like

Dans cette partie vous allez utiliser votre classe `Maze` pour en faire un petit jeu de type _rogue-like_.

### Concept

L'idÃ©e du jeu est d'incarner un personnage qui doit se dÃ©placer, en un minimum de temps (et/ou de coups) dans un labyrinthe et atteindre un ou plusieurs objectifs (ramasser un ensemble de trucs, atteindre un point particulier du labyrinthe, etc.) Des items pourront Ãªtre dissÃ©minÃ©s dans le labyrinthe.

Les items n'ont de limite que votre imagination. En voici quelques exemples :

- faille alÃ©atoire : lorsque le personnage passe sur cet item, il est tÃ©lÃ©portÃ© n'importe oÃ¹ dans le labyrinthe,
- shuffle : cet item re-gÃ©nÃ¨re un labyrinthe, sans changer la position du joueur ni celle de l'objectif,
- marteau : cet item permet de casser les murs autour de la cellule,
- carte magique : grÃ¢ce Ã  cet item le joueur voit les premiÃ¨res Ã©tapes Ã  suivre pour atteindre l'objectif (ou l'objectif le plus proche s'il y en a plusieurs),
- â€¦

Le niveau de difficultÃ© sera croissant Ã  mesure que le joueur gagne.

### Interface

Plusieurs choix s'offrent Ã  vous, parmis lesquels :

- rester dans le style poÃ©tiquement dÃ©suet de l'interface textuelle (en ASCII) ; dans ce cas, vous pourrez avoir besoin de quelques astuces :
  - les sÃ©quences d'Ã©chappement ANSI, qui permettent de positionner le curseur dans le terminal, effacer le terminal, ajouter des effets de couleurâ€¦
  - le module `getkey` qui permet les interactions avec le clavier
- opter pour une interface graphique avec [pygame](https://www.pygame.org/news)
- choisir un framework comme [pyxel](https://nuitducode.github.io/DOCUMENTATION/PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/)
- â€¦

